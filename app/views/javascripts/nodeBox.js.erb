/**
 * @class jsBox
 * @constructor
 */
var nodeBox = function(config, layer) {
   jsBox.superclass.constructor.call(this, config, layer);
   
   this.el.setStyle({height:'110px', width:'200px'})   
   
   if (config.element == 'node_subgraph'){
     console.log('node_subgraph!!!!!!!!!!')
     this.el.addClassName('has_pipe')        
   }
   
   this.build_from($(config.element))
   this.nParams = this.getNbrInputs();
   this.createTerminals();
   
   // Reposition the terminals when the jsBox is being resized
 
  document.observe('node:edit:' + config.id, function() {
    console.log('edit!!')    
  })
 
  document.observe('drag:done', function() {
    console.log('drag:done')
    new Ajax.Request("/users/1/pipes/1/nodes/1", {
      method: 'put',
      parameters: {'node[x]': 400, 'node[y]': 400},
      onSuccess: function(transport) {
        console.log('updated ' + transport.responseText)        
      }
    });    
  })
 
   this.ddResize.eventResize.subscribe(function(e, args) {
      this.positionTerminals();
      YAHOO.util.Dom.setStyle(this.textarea, "height", (args[0][1]-30)+"px");
   }, this, true);
   
};

YAHOO.extend(nodeBox, WireIt.Container, {
    getPostion:function(){
      return {x: this.el.getStyle('left'), y: this.el.getStyle('left')}
    },
    
    build_from: function(element) {
      this.el.appendChild(element);      
    },

   
   /**
    * Parse the textarea code to get the number of input parameters
    */
   getNbrInputs: function() {
      //var sParamList = this.textarea.value.match(/^[ ]*function[ ]*\((.*)\)[ ]*{/)[1];
      //var params = sParamList.split(',');
      //var nParams = (sParamList == "") ? 0 : parseInt(params.length);
      return 1/*nParams;*/
   },
   
   /**
    * Create (and re-create) the terminals with this.nParams input terminals
    */
   createTerminals: function() {
      
   	// Remove all the existing terminals
   	this.removeAllTerminals();
   	
      for(var i = 0 ; i < this.nParams ; i++) {
      	var term = this.addTerminal({xtype: WireIt.util.TerminalInput});
         term.jsBox = this;
         WireIt.sn(term.el, null, {position: "absolute", top: "-15px"});
      }

    var term = this.addTerminal({xtype: WireIt.util.TerminalOutput});      
          term.jsBox = this;
          WireIt.sn(term.el, null, {position: "absolute", bottom: "-15px"});
   	
      this.positionTerminals();

      // Declare the new terminals to the drag'n drop handler (so the wires are moved around with the container)
      this.dd.setTerminals(this.terminals);
   },
   
   /**
    * Reposition the terminals
    */
   positionTerminals: function() {
     if (this.terminals.length == 0) {
       return
     }
      // Calculate the width
      var widthStr = YAHOO.util.Dom.getStyle(this.el, 'width');
      var width = parseInt( widthStr.substr(0,widthStr.length-2), 10);

      var inputsIntervall = Math.floor(width/(this.nParams+1));

      for(var i = 0 ; i < this.terminals.length-1 ; i++) {
         YAHOO.util.Dom.setStyle(this.terminals[i].el, "left", (inputsIntervall*(i+1))-20+"px" );
         
         for(var j = 0 ; j < this.terminals[i].wires.length ; j++) {
            this.terminals[i].wires[j].redraw();
         }
      }

      YAHOO.util.Dom.setStyle(this.terminals[this.terminals.length-1].el, "left", Math.floor(width/2)-15+"px");

      for(var j = 0 ; j < this.terminals[this.terminals.length-1].wires.length ; j++) {
         this.terminals[this.terminals.length-1].wires[j].redraw();
      }
   },
   
   /**
    * Execute the module
    */
   execute: function() {
     console.log('nodeBox::execute')
     console.log(this.getPostion())

      // Eval each of the parameter functions : 
      var params = [];
      for(var i = 0 ; i < this.terminals.length-1 ; i++) {
         var term = this.terminals[i];
         var otherTerm = term.wires[0].getOtherTerminal(term);
         if(!otherTerm.jsBox.evalResult)
            otherTerm.jsBox.execute();
         params[i] = otherTerm.jsBox.evalResult;
      }
     
      this.evalResult = '123'
   },
   
   /**
    * Returns true if all the input wires have been evaluated, false otherwise
    */
   mayEval: function() {
      // For each input param :
      for(var i = 0 ; i < this.terminals.length-1 ; i++) {
         var term = this.terminals[i];
         if(term.wires.length != 1) return false;
         var otherTerm = term.wires[0].getOtherTerminal(term);
         if(!otherTerm.jsBox) return false;
         if( !otherTerm.jsBox.mayEval() ) return false;
      }
      return true;
   }
   
});


/**
 * Static function to run the "program"
 */
nodeBox.run = function() {
   console.log(this.getPostion())
   
   // Clear the previous results
   for(var i = 0; i < jsBox.jsBoxLayer.containers.length; i++) {
      jsBox.jsBoxLayer.containers[i].evalResult = null;
   }
   
   // Make a list of all the containers that may be run (no input params)
   var modules = [];
   for(var i = 0; i < jsBox.jsBoxLayer.containers.length; i++) {
      if( jsBox.jsBoxLayer.containers[i].mayEval() ) {
         modules.push( jsBox.jsBoxLayer.containers[i] );
      }
   }
   
   // Eval the "sources" modules 
   for(var i = 0 ; i < modules.length ; i++) {
      modules[i].execute();
   }
   
};

/**
 * Adds a jsBox to the layer
 */
nodeBox.addModule = function (element) {
   jsBox.jsBoxLayer.addContainer({xtype: nodeBox, position: [50,250], element:element});
};
