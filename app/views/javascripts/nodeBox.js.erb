var nodeBox = function(config, layer) {
    if (config.element == 'node_last') {    config.close = false }

   nodeBox.superclass.constructor.call(this, config, layer);
   
   var user_id = <%= params[:user_id] %>
   var pipe_id = config.has_pipe

   this.result = function() {
     return '123'
   }

   if (this.has_subgraph()) { 
     this.editButton = WireIt.cn('div', {className: 'WireIt-Container-editbutton '} );
     this.el.appendChild(this.editButton);
     
     YAHOO.util.Event.addListener(this.editButton, "click", function() {
       window.open("/users/" + user_id + "/pipes/" + pipe_id)  
     }, this, true);     
     this.el.addClassName('has_pipe') 
   } 
   
//   new YAHOO.util.CustomEvent("eventAddWire").fire(wire)
  YAHOO.util.Event.addListener(document, "eventAddWire", function() { 
 })
 
   this.el.setStyle(this.is_last() ? {height:'19px', width: '150px'} : {height:'110px', width:'200px'})        

   this.el.object_ref = this
   this.nParams = 1
   
   this.build_from($(config.element))
   this.createTerminals();

  
   // Reposition the terminals when the box is being resized
  document.observe('node:edit:' + config.id, function() { console.log('edit!!') })

  Event.observe(this.el, 'drag:done', function(event) {
    var x = parseInt(event.target.getStyle('left'))
    var y = parseInt(event.target.getStyle('top'))
    
    var node_id = event.target.object_ref.config.node_id
    var user_id = <%= params[:user_id] %>
    var pipe_id = <%= params[:pipe_id] %>  
        
    new Ajax.Request("/users/" + user_id + "/pipes/" + pipe_id + "/nodes/" + node_id, {
      method: 'put',
      parameters: {'node[x]': x, 'node[y]': y},
      onSuccess: function(transport) {
      }
    });    
    
    event.stop()
  })
 
   this.ddResize.eventResize.subscribe(function(e, args) {
      this.positionTerminals();
      YAHOO.util.Dom.setStyle(this.textarea, "height", (args[0][1]-30)+"px");
   }, this, true);
   
};

YAHOO.extend(nodeBox, WireIt.Container, {
    getPostion:function(){
      return {x: this.el.getStyle('left'), y: this.el.getStyle('left')}
    },
    
    build_from: function(element) {
      this.el.appendChild(element.cloneNode(true));      
    },
   
   has_subgraph : function() {
     return this.config.element == 'node_subgraph'
   },
   
   is_last: function() {
     return this.config.element == 'node_last'
   },

   createTerminals: function() {
     this.removeAllTerminals();

     for(var i = 0 ; i < this.nParams ; i++) {
       var term = this.addTerminal({xtype: WireIt.util.TerminalInput});
       term.nodeBox = this;
       WireIt.sn(term.el, null, {position: "absolute", top: "-15px"});
     }

     if (!this.is_last()) {
       var term = this.addTerminal({xtype: WireIt.util.TerminalOutput});      
       term.nodeBox = this;
       WireIt.sn(term.el, null, {position: "absolute", bottom: "-15px"});
     }
   	  
     this.positionTerminals();

     // Declare the new terminals to the drag'n drop handler (so the wires are moved around with the container)
     this.dd.setTerminals(this.terminals);
   },
   
   /**
    * Reposition the terminals
    */
   positionTerminals: function() {
     if (this.terminals.length == 0) {
       return
     }
      // Calculate the width
      var widthStr = YAHOO.util.Dom.getStyle(this.el, 'width');
      var width = parseInt( widthStr.substr(0,widthStr.length-2), 10);

      var inputsIntervall = Math.floor(width/(this.nParams+1));

      for(var i = 0 ; i < this.terminals.length-1 ; i++) {
         YAHOO.util.Dom.setStyle(this.terminals[i].el, "left", (inputsIntervall*(i+1))-20+"px" );
         
         for(var j = 0 ; j < this.terminals[i].wires.length ; j++) {
            this.terminals[i].wires[j].redraw();
         }
      }

      YAHOO.util.Dom.setStyle(this.terminals[this.terminals.length-1].el, "left", Math.floor(width/2)-15+"px");

      for(var j = 0 ; j < this.terminals[this.terminals.length-1].wires.length ; j++) {
         this.terminals[this.terminals.length-1].wires[j].redraw();
      }
   },
   
   execute: function() {
     this.evalResult = this.config.element
     return this.config.element
   },
   
   mayEval: function() {
      return this.terminals.each(function(term) {
        return term.wires[0].getOtherTerminal(term);
      }) || false
   }
   
});


/**
 * Adds a box to the layer
 */
nodeBox.addModule = function (element, namespace) {
    var user_id = <%= params[:user_id] %>
    var pipe_id = <%= params[:pipe_id] %>
    
     new Ajax.Request("/users/" + user_id + "/pipes/" + pipe_id + "/nodes", {
       method: 'post',
       parameters: {'node[x]': 50, 'node[y]': 250, 'node[kind]': 'nodeBox', 'node[element]': element, 'node[has_pipe]': false },
       onSuccess: function(transport) {
         var response = (transport.responseText.evalJSON(true));   
         nodeBox.layer.addContainer({xtype: nodeBox, node_id: response.node_id, pipe_id: response.pipe_id, user_id: response.user_id, position: [50,250], element:element});   
       }
     });   
   
       
};
